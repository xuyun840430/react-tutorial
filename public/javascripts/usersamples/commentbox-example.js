/**
 * Example of React Tutorial
 */

/**
 * CommentBox:
 * Architecture:
    -CommentBox
      -CommentList
        -Comment
      -CommentForm
 * When a user submits a comment, we will need to refresh the list of comments to include the new one.
 * It makes sense to do all of this logic in CommentBox since CommentBox owns the state that represents
 * the list of comments.
 */

// build the CommentBox component, which is just a simple <div>
var CommentBox = React.createClass({
  /*
   getInitialState() executes exactly once during the lifecycle of the component
   and sets up the initial state of the component.
   */
  getInitialState: function () {
    return {data: []};
  },

  /*
   When the component is first created, we want to GET some JSON from the server and update the state
   to reflect the latest data. We're going to use jQuery to make an asynchronous request to the server we
   started earlier to fetch the data we need.
   */
  loadCommentsFromServer: function () {
    $.ajax({
      url: this.props.url, // url: /api/comments
      dataType: 'json',
      cache: false,
      success: function (data) {
        this.setState({data: data}); // Calling to this.setState() is the key to dynamic updates
      }.bind(this),
      error: function (xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },

  // We need to pass data from the child component back up to its parent. We do this in our parent's render method by
  // passing a new callback (handleCommentSubmit) into the child, binding it to the child's onCommentSubmit event.
  handleCommentSubmit: function (comment) {
    /*
     The application is now feature complete but it feels slow to have to wait for the request to complete before
     your comment appears in the list. Adding optimistically  this comment to the list to make the app feel faster.
     */
    var comments = this.state.data;
    // Optimistically set an id on the new comment. It will be replaced by an
    // id generated by the server. In a production application you would likely
    // not use Date.now() for this and would have a more robust system in place.
    comment.id = Date.now;
    var newComments = comments.concat([comment]);
    this.setState({data: newComments});

    // Submit to the server and refresh the list
    $.ajax({
      url: this.props.url,
      dataType: 'json',
      type: 'POST',
      data: comment,
      success: function (data) {
        /*
         Events Handling
         - In handleCommentSubmit()
         -> call 'this.setState({data: data})' by using 'data:comment', i.e.: this.state.data=comment [CommentBox]
         -> trigger state change event for '<CommentList data={this.state.data}/>' by passing 'this.state.data' [CommentBox]
         -> perform 'CommentList'view update by using 'this.props.data' [CommentList]
         */
        this.setState({data: data});
      }.bind(this),
      error: function (xhr, status, err) {
        this.setState({data: comments});
        console.error(this.props.url, status, err.toString());
      }
    })
  },

  // componentDidMount is a method called automatically by React after a component is rendered for the first time.
  componentDidMount: function () {
    this.loadCommentsFromServer();
    // call loadCommentsFromServer() when the component is first loaded and every 2 seconds after that
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },

  // Note that native HTML element names start with a lowercase letter,
  // while custom React class names begin with an uppercase letter.
  render: function () {
    // Notice how we're mixing HTML tags and components we've built
    return ( // 'this.props.data' is as argument send to CommentBox class
      <div className="commentBox">
        <h1>Comments</h1>
        <CommentList data={this.state.data}/>
        <CommentForm onCommentSubmit={this.handleCommentSubmit}/>
      </div>
    );
  }
});

/**
 * CommentList:
 */
var CommentList = React.createClass({
  render: function () {
    // Pass data as comment argument by mapping, i.e.: comment with {id, author, text} structure
    var commentNodes = this.props.data.map(function (comment) {
      return (
        // Passing author to comment class
        <Comment author={comment.author} key={comment.id}>
          {comment.text}
        </Comment>
      )
    });

    return (
      // Data is available in the CommentList, render the comments dynamically
      <div className="commentList">
        {commentNodes}
      </div>
    );
  }
});

/**
 * CommentForm:
 * CommentForm component should ask the user for their name and comment text and send a request
 * to the server to save the comment.
 */
var CommentForm = React.createClass({
  // In React, components should always represent the state of the view and not only at the point of initialization.
  // Hence, we will be using this.state to save the user's input as it is entered.
  getInitialState: function () {
    return {author: '', text: ''};
  },
  handleAuthorChange: function (e) {
    this.setState({author: e.target.value});
  },
  handleTextChange: function (e) {
    this.setState({text: e.target.value});
  },

  // When the user submits the form, we should clear it, submit a request to the server
  // and refresh the list of comments.
  handleSubmit: function (e) {
    // Call preventDefault() on the event to prevent the browser's default action of submitting the form
    e.preventDefault();

    var author = this.state.author.trim();
    var text = this.state.text.trim();
    if (!text || !author) {
      return;
    }

    // CommentBox has made the callback available to CommentForm via the onCommentSubmit prop, the CommentForm
    // can call the callback when the user submits the form
    this.props.onCommentSubmit({author: author, text: text}); // Send request to server

    /*
     Events Handling
     - Handling flow (bottom up): 'user submit'
     -> call 'handleSubmit()' [CommentForm]
     -> call 'this.setState(data)' [CommentForm]
     -> trigger 'onChange(e)' in 'render()'
     -> call 'handleAuthorChange(e)' and 'handleTextChange(e)' to handle event [CommentForm]
     -> perform to CommentForm view by React
     */
    this.setState({author: '', text: ''});
  },

  /*
   In our <input> elements, we set the value prop to reflect the state of the component and attach onChange handlers
   to them. These <input> elements with a value set are called controlled components.
   */
  render: function () {
    /*
     Events Handling
     - Handling flow (bottom up): 'user submit'
                                    -> call 'handleSubmit()' [CommentForm]
                                    -> trigger 'onCommentSubmit(comment)' [CommentForm->CommentBox]
                                    -> call 'handleCommentSubmit(comment)' [CommentBox]
                                    -> update data to server

     - React attaches event handlers to components using a camelCase naming convention,e.g.: onChange, onSubmit...
       Attaching onChange handlers to the two <input> elements. As the user enters text into the <input> fields,
       the attached onChange callbacks are fired and the state of the component is modified. Subsequently, the rendered
       value of the input element will be updated to reflect the current component state.
     - We attach an onSubmit handler to the form that clears the form fields when the form is submitted with valid input.
     */
    return (
      <form className="commentForm" onSubmit={this.handleSubmit}>
        <input
          type="text"
          placeholder="Your Name"
          value={this.state.author}
          onChange={this.handleAuthorChange}
        />
        <input
          type="text"
          placeholder="Say something..."
          value={this.state.text}
          onChange={this.handleTextChange}
        />
        <input type="submit" value="Post"/>
      </form>
    );
  }
});

/**
 * Comment:
 * Create the Comment component, which will depend on data passed in from its parent.
 * Data passed in from a parent component is available as a 'property' on the child component.
 */
var Comment = React.createClass({
  // Make rawMarkup function to protect from an XSS attack
  rawMarkup: function () {
    var rawMarkup = marked(this.props.children.toString(), {sanitize: true});
    return { __html: rawMarkup};
  },

  // These 'properties' are accessed through this.props. Using props, we will be able to
  // read the data passed to the Comment from the CommentList
  render: function () {
    return (
      <div className="comment">
        <h2 className="commentAuthor">
          {this.props.author}
        </h2>
        <span dangerouslySetInnerHTML={this.rawMarkup()} />
      </div>
    );
  }
});

// Define data to pass
var data = [
  {id: 1, author: "Yun Xu", text: "This is one comment"},
  {id: 2, author: "Qian Zhu", text: "This is *another* comment"}
];

// It is important that ReactDOM.render remain at the bottom of the script for this tutorial.
// ReactDOM.render should only be called after the composite components have been defined.
ReactDOM.render(
  //<CommentBox data={data}/>, // Get hard-coded data into CommentList in a modular way
  <CommentBox url="/api/comments" pollInterval={2000} />, //  replace the hard-coded data with some dynamic data from the server
  document.getElementById('container')
);
